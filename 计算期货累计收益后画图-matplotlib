#接上
import matplotlib as plt
from pylab import *
------------------------
1.导出为csv／xlsx文件，利用数据透视表画图；
df_pic.to_csv('futures_1.csv',encoding='gbk')
------------------------
2.手动赋上初始值（这里初始值不多，工作量尚可）
df1.iloc[0,9]=-540
df1.iloc[29,9]=-750
df1.iloc[55,9]=1850
df1.iloc[84,9]=-130
df1.iloc[113,9]=100
------------------------
3.以日期为横轴，日／累计净收益为竖轴画柱状／折线图；
df_pic=df_pic.reset_index() #所有列，包括原来的index列，这里都可以被使用了
print(type(df_pic.iloc[1,0])) #查看这时的交易日期列，发现20180626是以“整数”格式存储的
------------------------
3.1 设置图像参数
fig=plt.figure(figsize=(12,4),dpi=100) #()中为图像的大小与清晰度
------------------------
3.2.1 获取数据并且转化格式
date = df_pic['交易日期'] #数据存储形式为Series，该Series中数据格式为整数
date_container=[] #将所有日期以标准datetime的格式存储起来
for i in date:
    a=str(i)
    b=pd.to_datetime(a)
    date_container.append(b)
dailyreturn = df_pic['日净收益']
accreturn=df_pic['累计净收益']
3.2.2 获取数据不用转化格式
date = df_pic['交易日期']
dailyreturn = df_pic['日净收益']
accreturn=df_pic['累计净收益']
benchmark=df_pic['benchmark']
-------------------------
3.3 在图中手动添加一条0值的线，设为benchmark
df_pic=df_pic.reset_index()
df_pic['benchmark']=0
-------------------------
3.4 画交易日期／日净收益之间的柱状图
3.4.1 
plt.bar(date_container, dailyreturn,label='daily return')  
#标明label是因为这里有多个图，要标明每个图叫什么
#date_container在这里是一个包含datetime格式的序列，在作为横轴时，系统自动把时间序列全部补齐，所以有空天
3.4.2
plt.bar(range(len(dailyreturn)), dailyreturn,tick_label=date) 
#效果是等价的，只是先取了长度，然后再把标签贴上去，但是这样做是不会有空天出来的！
-------------------------
3.5 画交易日期／累计净收益之间的折线图+benchmark
plt.plot(date_container,accreturn,'o-',color = 'g',label='accumulative return') 
plt.plot(range(len(accreturn)),benchmark,'r',color ='k',label='0-axis')
#'o-'和'r'都是折线的形状，前者为圆点图，后者为直线；
#两种体系7种颜色 r g b y m c k （红，绿，蓝，黄，品红，青，黑）
-------------------------
3.6 综合
plt.legend(loc=3) #将标签总和在左下角
plt.xlabel('trading day') #设置大图的x，y轴叫是什么
plt.xticks(rotation=90) #将x轴的tick转90度
plt.ylabel('')
plt.title('Return of futures')
plt.savefig('return4.19_7.13.png',dpi=100) #先存储再show，不然show完了会生成一个新的空白的图片
plt.show()

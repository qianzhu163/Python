#接上
1.引入时间module与操作Oracle的module
from datetime import timedelta, datetime #引入时间模块
import cx_Oracle
conn=cx_Oracle.connect("wind_read_only", "wind_read_only", "192.168.0.223:1521/orcl")
cursor=conn.cursor()
--------------------
2.获取想要的时间
yesterday = datetime.today() + timedelta(-1) #获取昨天datetime格式的日期＝现在的datetime加上想要的时间间隔
-datetime.datetime(2018, 7, 16, 17, 33, 51, 228824)
yesterday_format = yesterday.strftime('%Y%m%d') #字符串格式化日期，括号里为我想要的设置的格式
-20180716
--------------------
3.获取数据
sql="select TRADEDATE,SEC_CODE,PRICE,QUANTITY from CHINAAMCQUANT.PROD_TRADE_BAK where TRADEDATE >"\
+yesterday_format+"and SEC_CODE in ('RB1810','HC1810','J1809','I1809','ZC809')"
#\：系统识别不断行换行的方式，两个字符串之间加入一个参数
cursor.execute(sql)
updatedata=cursor.fetchall() #光标获得所有执行sql语句后得到的数据
conn.close() #关闭连接
update=pd.DataFrame(updatedata,columns=['交易日期','证券代码','成交价格','成交数量']) #将获得的list做成dataframe
--------------------
4.合并数据表（625之前的数据数据库里没有，必须通过本地文件走）
def multiple(x):
    if '1810' in x:
        return 10
    else:
        return 100
update['multiple']=update['证券代码'].apply(multiple)
update['成交金额']=update['成交价格']*update['成交数量']*update['multiple']
df=pd.read_csv('before713.csv',usecols=[0,2,5,6,9],encoding='gbk')
df['multiple']=df['证券代码'].apply(multiple)
final=pd.concat([df,update],ignore_index=True,sort=True) 
#之前final drop过几列，这里final又会有两列multiple、成交数量多出来;drop不是真的“扔掉了”，所以前面不扔了，后面一起扔
final=final[final['证券代码']!='IF1812']
final=final.drop(['成交价格'],axis=1)
